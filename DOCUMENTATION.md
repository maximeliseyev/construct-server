# Construct Server: Protocol Documentation

**Version:** 1.0.0  
**Last Updated:** 2026-02-15  
**Status:** Living Document

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Protocol Stack](#protocol-stack)
3. [Complete System Flow](#complete-system-flow)
4. [X3DH Key Agreement](#x3dh-key-agreement)
5. [Double Ratchet Encryption](#double-ratchet-encryption)
6. [Message Delivery](#message-delivery)
7. [Authentication & Security](#authentication--security)
8. [API Reference](#api-reference)
9. [Implementation Status](#implementation-status)

---

## Executive Summary

Construct is an end-to-end encrypted messaging system based on the **Signal Protocol** (X3DH + Double Ratchet) with extensions for **crypto-agility**, **post-quantum cryptography (PQC)**, and **multi-protocol support**.

### Grand Vision

```
Foundation:     Signal Protocol + Noise Framework
Extensions:     Crypto Agility + PQC (ML-KEM-768)
Future:         Encrypted Voice/Video Calls + MLS Group Messaging
```

### Current State (2026-02-15)

✅ **Implemented:**
- X3DH key agreement (Ed25519 + X25519)
- Double Ratchet encryption (ChaCha20-Poly1305)
- Device-based authentication (passwordless)
- Redis Streams delivery queue
- Kafka as single source of truth
- State management with skipped message keys
- nextSince pagination (fixed 2026-02-15)

⚠️ **In Progress:**
- E2E integration tests with real cryptography
- Protocol compliance testing framework

❌ **Not Yet Implemented:**
- Crypto-agility framework
- Post-quantum cryptography (ML-KEM-768, Dilithium)
- MLS group messaging
- Encrypted voice/video calls

---

## Protocol Stack

### Cryptographic Foundation

```
Layer 4: Application (E2EE Messages, Media, Calls)
         ↓
Layer 3: Double Ratchet (Message Encryption)
         ↓
Layer 2: X3DH (Session Initialization)
         ↓
Layer 1: Primitive Operations (Ed25519, X25519, ChaCha20-Poly1305)
```

### Protocol Suite Identifier

```rust
pub enum CryptoSuite {
    /// Suite 0x01: Ed25519 + X25519 + ChaCha20-Poly1305
    /// - Identity Key: Ed25519
    /// - Ephemeral Keys: X25519
    /// - Encryption: ChaCha20-Poly1305
    Classic = 0x01,
    
    /// Suite 0x10: Hybrid PQ (FUTURE)
    /// - Identity Key: Ed25519 + Dilithium3
    /// - Ephemeral Keys: X25519 + ML-KEM-768
    /// - Encryption: ChaCha20-Poly1305
    HybridPQ = 0x10,
}
```

**Current Implementation:** Suite 0x01 only  
**Roadmap:** Suite 0x10 by Q2 2026

---

## Complete System Flow

### The Two IDs Problem

| ID Type | Generated By | Format | Purpose |
|---------|--------------|--------|---------|
| **Message ID** | Server (UUID v4) | `c78b9bf2-715c-4621-...` | Deduplication, logging |
| **Stream ID** | Redis (auto) | `1707584371151-0` | Pagination (`nextSince`) |

**Critical Bug (FIXED 2026-02-15):** `nextSince` field was omitted when `None`, causing infinite client polling loops.

**Fix:** Always return `Some(stream_id)` - echo client's `since` when no new messages.

---

### Phase 0: Device Registration

Client generates keys **on device** (never sent to server):
- Identity Key Pair (Ed25519) - long-term
- Signed PreKey Pair (X25519) - rotated every 7 days
- One-Time PreKeys (100+) - consumed on use
- Device Key Pair - for authentication

```http
POST /api/v1/auth/register-device
Content-Type: application/json

{
  "deviceId": "alice-iphone",
  "password": "device-secret",  // Only for PoW challenge
  "identityKey": "base64(Ed25519_public)",
  "signedPreKey": "base64(X25519_public)",
  "signedPreKeySignature": "base64(Ed25519_signature)",
  "oneTimePreKeys": ["base64...", "base64...", ...],
  "suiteId": 1
}
```

**Response:**
```json
{
  "userId": "767c4759-...",
  "accessToken": "jwt...",
  "refreshToken": "jwt..."
}
```

**Security Notes:**
- ✅ Password only used for PoW challenge (anti-spam)
- ✅ Device IS the identity (no username/password auth)
- ✅ All cryptographic keys generated client-side
- ✅ Server never sees private keys

---

### Phase 1: Key Exchange (X3DH Initialization)

Alice wants to send a message to Bob. First, she fetches Bob's public key bundle:

```http
GET /api/v1/keys/{bob_user_id}
Authorization: Bearer <alice_jwt>
```

**Response:**
```json
{
  "identityPublicKey": "base64(Bob_IK_public)",
  "signedPrekey": "base64(Bob_SPK_public)",
  "signedPrekeySignature": "base64(signature)",
  "oneTimePrekey": "base64(Bob_OPK_public)" | null,
  "suiteId": 1
}
```

**Client MUST verify:** `Ed25519.verify(identityPublicKey, signedPrekey, signature) == true`

If signature verification fails → **ABORT** (potential MITM attack)

---

### Phase 2: X3DH Key Agreement (Client-Side)

Alice performs X3DH to establish shared secret with Bob:

```
1. Generate ephemeral key pair: EK_A (X25519)

2. Perform 4 Diffie-Hellman operations:
   DH1 = ECDH(IK_A_private, SPK_B_public)
   DH2 = ECDH(EK_A_private, IK_B_public)
   DH3 = ECDH(EK_A_private, SPK_B_public)
   DH4 = ECDH(EK_A_private, OPK_B_public)  // if OPK present

3. Derive shared secret:
   SK = HKDF-SHA256(
       salt = 0xFF...FF (32 bytes),
       ikm = DH1 || DH2 || DH3 || DH4,
       info = "ConstructX3DH"
   )

4. Initialize Double Ratchet:
   - Root Key = SK
   - Chain Key = HKDF(SK, "chain-key")
   - Message Number = 0
```

**Reference:** Signal Protocol X3DHv3 Specification

---

### Phase 3: Message Encryption (Double Ratchet)

Alice encrypts her message using Double Ratchet:

```
1. Derive message key:
   message_key = HMAC-SHA256(chain_key, 0x01)
   chain_key = HMAC-SHA256(chain_key, 0x02)

2. Encrypt plaintext:
   ciphertext = ChaCha20-Poly1305.encrypt(
       key = message_key,
       nonce = random(12 bytes),
       plaintext = "Hello Bob!",
       associated_data = header
   )

3. Build message header:
   {
     "ratchetPublicKey": "base64(EK_A_public)",
     "previousChainLength": 0,
     "messageNumber": 0
   }
```

**Message Format:**
```json
{
  "recipientId": "bob_uuid",
  "ciphertext": "base64(encrypted_data)",
  "nonce": "base64(12_bytes)",
  "header": {
    "ratchetPublicKey": "base64(ephemeral_key)",
    "previousChainLength": 0,
    "messageNumber": 0
  },
  "suiteId": 1,
  "timestamp": 1707584371151
}
```

---

### Phase 4: Message Transmission

```http
POST /api/v1/messages
Authorization: Bearer <alice_jwt>
Content-Type: application/json

{
  "recipientId": "bob_uuid",
  "ciphertext": "base64...",
  "nonce": "base64...",
  "header": { ... },
  "suiteId": 1
}
```

**Server-Side Processing:**

```
1. Validate JWT → extract sender_id
2. Generate message_id (UUID v4)
3. Store in PostgreSQL:
   INSERT INTO messages (id, sender_id, recipient_id, ciphertext, ...)

4. Publish to Kafka:
   Topic: "construct-messages"
   Key: recipient_id
   Value: { message_id, sender_id, ciphertext, ... }

5. Check recipient online status (Redis):
   IF online:
     XADD messages:{recipient_id} * { message_id, ... }
     PUBLISH user:online:{recipient_id} "new_message"
   ELSE:
     XADD offline:{recipient_id} * { message_id, ... }

6. Return response:
   {
     "id": "message_uuid",
     "status": "sent",
     "timestamp": 1707584371151
   }
```

---

### Phase 5: Message Delivery (Long Polling)

Bob's device polls for new messages:

```http
GET /api/v1/messages?since=1707584371151-0&timeout=25
Authorization: Bearer <bob_jwt>
```

**Server Response:**

**Case 1: New messages available immediately**
```json
{
  "messages": [
    {
      "id": "c78b9bf2-...",
      "senderId": "alice_uuid",
      "ciphertext": "base64...",
      "nonce": "base64...",
      "header": { ... },
      "timestamp": 1707584371151,
      "streamId": "1707584371151-0"
    }
  ],
  "nextSince": "1707584371151-0",
  "hasMore": false
}
```

**Case 2: No messages (after timeout)**
```json
{
  "messages": [],
  "nextSince": "1707584371151-0",  // ✅ ECHOED BACK (fixed bug)
  "hasMore": false
}
```

**Case 3: No messages, invalid since**
```json
{
  "messages": [],
  "nextSince": "0-0",  // Reset to start
  "hasMore": false
}
```

**Critical:** `nextSince` field is **ALWAYS present** to prevent infinite polling loops.

---

### Phase 6: Message Decryption (Client-Side)

Bob decrypts received message:

```
1. Extract header:
   ratchet_key = header.ratchetPublicKey
   message_number = header.messageNumber

2. Check if ratchet_key is new:
   IF ratchet_key != current_ratchet_key:
     perform_dh_ratchet(ratchet_key)

3. Derive message key:
   message_key = HMAC-SHA256(chain_key, 0x01)
   chain_key = HMAC-SHA256(chain_key, 0x02)

4. Decrypt:
   plaintext = ChaCha20-Poly1305.decrypt(
       key = message_key,
       nonce = nonce,
       ciphertext = ciphertext,
       associated_data = header
   )

5. Verify MAC → if fails: InvalidCiphertext error

6. Display plaintext to user
```

**Out-of-Order Message Handling:**

If message N+5 arrives before N+1:
- Store message_key for N+5 in `skipped_message_keys` map
- Wait for messages N+1 through N+4
- Apply cleanup after 7 days (prevent DoS)

**Reference:** Double Ratchet Specification (Signal)

---

## X3DH Key Agreement

### Specification Conformance

Our X3DH implementation conforms to **Signal Protocol Specification v3**.

**Reference:** https://signal.org/docs/specifications/x3dh/

### Key Bundle Format

```rust
pub struct KeyBundle {
    /// Long-term identity key (IK) - Ed25519 public key
    /// Used for: Signature verification, long-term authentication
    pub identity_public_key: Vec<u8>,
    
    /// Medium-term signed prekey (SPK) - X25519 public key
    /// Rotated: Every 7 days
    /// Signed by: IK private key
    pub signed_prekey: Vec<u8>,
    
    /// Signature over SPK - Ed25519 signature
    pub signed_prekey_signature: Vec<u8>,
    
    /// One-time prekey (OPK) - X25519 public key
    /// Optional: Consumed after first use
    pub one_time_prekey: Option<Vec<u8>>,
    
    /// Suite identifier
    pub suite_id: u8,
}
```

### Security Properties

1. **Forward Secrecy:** OPKs deleted after use
2. **Deniability:** No long-term signature in message
3. **Authentication:** SPK signature proves identity
4. **MITM Protection:** Client verifies SPK signature

---

## Double Ratchet Encryption

### Ratchet State

```rust
pub struct DoubleRatchetSession {
    /// Current sending/receiving chain key
    pub chain_key: [u8; 32],
    
    /// Root key for deriving new chain keys
    pub root_key: [u8; 32],
    
    /// Current DH ratchet key pair
    pub dh_ratchet: X25519KeyPair,
    
    /// Message number in current chain
    pub message_number: u32,
    
    /// Skipped message keys (for out-of-order)
    pub skipped_message_keys: HashMap<u32, [u8; 32]>,
    
    /// Max skipped messages (DoS protection)
    pub max_skip: usize,  // Default: 1000
}
```

### Symmetric Ratchet

```
Message Key Derivation:
  KDF_CK(CK) = (CK_new, MK)
  
  CK_new = HMAC-SHA256(CK, 0x02)
  MK     = HMAC-SHA256(CK, 0x01)
```

### DH Ratchet

```
When new ratchet key received:
  1. DH_out = ECDH(our_private, their_public)
  2. (RK_new, CK_send) = HKDF(RK, DH_out)
  3. Generate new ephemeral key pair
  4. DH_in = ECDH(new_private, their_public)
  5. (RK_new, CK_recv) = HKDF(RK_new, DH_in)
```

### Security Properties

1. **Forward Secrecy:** Old keys deleted after ratchet
2. **Break-in Recovery:** New DH ratchet = new security
3. **Out-of-Order:** Buffered keys for delayed messages
4. **DoS Protection:** Max 1000 skipped keys, 7-day timeout

---

## Message Delivery

### Delivery Architecture

```
┌─────────────┐
│  PostgreSQL │ ← Persistent storage (source of truth)
└──────┬──────┘
       │
       ↓ (Kafka)
┌─────────────┐
│    Kafka    │ ← Event stream (durability)
└──────┬──────┘
       │
       ↓ (Delivery Worker)
┌─────────────┐
│    Redis    │ ← Fast delivery queue
│   Streams   │   (online: messages:{user_id})
│             │   (offline: offline:{user_id})
└─────────────┘
```

### Redis Streams Format

**Stream ID:** `{timestamp}-{sequence}` (e.g., `1707584371151-0`)

**Entry:**
```json
{
  "message_id": "c78b9bf2-...",
  "sender_id": "alice_uuid",
  "ciphertext": "base64...",
  "nonce": "base64...",
  "header": "{...}",
  "timestamp": "1707584371151"
}
```

### Pagination (nextSince)

**Critical Contract:**

1. `nextSince` field **MUST** always be present in response
2. When no messages: echo client's `since` parameter
3. When messages: return last message's `stream_id`
4. Special values:
   - `"0-0"` - start of stream
   - `"$"` - end of stream (live tail)

**Bug (FIXED 2026-02-15):**
- Before: `#[serde(skip_serializing_if = "Option::is_none")]` caused field omission
- After: Always return `Some(stream_id)`, field always serialized

### Delivery Guarantees

- **At-Least-Once:** Messages may be delivered multiple times
- **Idempotency:** Client MUST deduplicate by `message_id`
- **Ordering:** Redis Streams guarantee FIFO per recipient
- **Durability:** Kafka + PostgreSQL ensure no message loss

---

## Authentication & Security

### Device-Based Authentication

**Philosophy:** Device IS the identity. No passwords, no usernames.

**Registration:**
1. Device generates Ed25519 identity key pair
2. Device creates PoW challenge solution (anti-spam)
3. Server issues JWT tied to device public key

**Authentication:**
```
JWT Claims:
{
  "sub": "user_uuid",
  "device_id": "device_uuid",
  "iat": 1707584371,
  "exp": 1707670771,  // 24 hours
  "iss": "construct-server"
}
```

**Token Refresh:**
```http
POST /api/v1/auth/refresh
Content-Type: application/json

{
  "refreshToken": "jwt..."
}
```

**Security Properties:**
- ✅ No password brute-force attacks
- ✅ No password reuse across services
- ✅ Server never sees authentication secrets
- ✅ Device compromise = revoke device only (not account)

### Proof-of-Work (Anti-Spam)

**Rate Limits:**
- PoW challenges: 10 per hour per IP
- Registrations: 5 per hour per IP

**Challenge Format:**
```json
{
  "challengeId": "uuid",
  "difficulty": 1,  // Number of leading zero bits
  "expires": 1707584671
}
```

**Solution:**
```
Find nonce such that:
  SHA256(challenge_id || nonce) has <difficulty> leading zero bits
```

---

## API Reference

### Authentication Endpoints

#### POST /api/v1/auth/challenge
Get PoW challenge for registration.

**Request:** `{}`

**Response:**
```json
{
  "challengeId": "uuid",
  "difficulty": 1,
  "expiresAt": 1707584671
}
```

#### POST /api/v1/auth/register-device
Register new device.

**Request:**
```json
{
  "deviceId": "alice-iphone",
  "password": "device-secret",
  "identityKey": "base64...",
  "signedPreKey": "base64...",
  "signedPreKeySignature": "base64...",
  "oneTimePreKeys": ["base64...", ...],
  "powChallengeId": "uuid",
  "powSolution": 12345,
  "suiteId": 1
}
```

**Response:**
```json
{
  "userId": "uuid",
  "accessToken": "jwt",
  "refreshToken": "jwt"
}
```

#### POST /api/v1/auth/refresh
Refresh access token.

**Request:**
```json
{
  "refreshToken": "jwt"
}
```

**Response:**
```json
{
  "accessToken": "jwt",
  "refreshToken": "jwt"
}
```

---

### Key Management Endpoints

#### GET /api/v1/keys/{user_id}
Get user's public key bundle.

**Headers:** `Authorization: Bearer <jwt>`

**Response:**
```json
{
  "identityPublicKey": "base64...",
  "signedPrekey": "base64...",
  "signedPrekeySignature": "base64...",
  "oneTimePrekey": "base64..." | null,
  "suiteId": 1
}
```

#### POST /api/v1/keys/prekeys
Upload new one-time prekeys.

**Request:**
```json
{
  "oneTimePrekeys": ["base64...", "base64...", ...]
}
```

**Response:** `{ "uploaded": 100 }`

---

### Messaging Endpoints

#### POST /api/v1/messages
Send encrypted message.

**Request:**
```json
{
  "recipientId": "uuid",
  "ciphertext": "base64...",
  "nonce": "base64...",
  "header": {
    "ratchetPublicKey": "base64...",
    "previousChainLength": 0,
    "messageNumber": 0
  },
  "suiteId": 1
}
```

**Response:**
```json
{
  "id": "message_uuid",
  "status": "sent",
  "timestamp": 1707584371151
}
```

#### GET /api/v1/messages
Poll for new messages (long polling).

**Query Parameters:**
- `since` (optional): Stream ID to start from (default: "0-0")
- `timeout` (optional): Max wait time in seconds (default: 25, max: 30)

**Response:**
```json
{
  "messages": [
    {
      "id": "uuid",
      "senderId": "uuid",
      "ciphertext": "base64...",
      "nonce": "base64...",
      "header": { ... },
      "timestamp": 1707584371151,
      "streamId": "1707584371151-0"
    }
  ],
  "nextSince": "1707584371151-0",
  "hasMore": false
}
```

**Critical:** `nextSince` is **ALWAYS** present in response.

---

## Implementation Status

### ✅ Completed

**Core Protocol:**
- [x] X3DH key agreement (Ed25519 + X25519)
- [x] Double Ratchet encryption (ChaCha20-Poly1305)
- [x] Message number tracking
- [x] Out-of-order message handling
- [x] Skipped message keys with cleanup (7 days)

**Infrastructure:**
- [x] Device-based authentication (passwordless)
- [x] JWT-based access tokens
- [x] PoW anti-spam system
- [x] Redis Streams delivery queue
- [x] Kafka as source of truth
- [x] PostgreSQL persistent storage
- [x] Long polling with timeout
- [x] nextSince pagination (bug fixed 2026-02-15)

**Testing:**
- [x] Unit tests for crypto primitives
- [x] Integration tests for auth flow
- [x] Contract tests for nextSince pagination
- [x] Protocol compliance test framework

### ⚠️ In Progress

- [ ] E2E integration tests with real crypto
- [ ] Performance benchmarks
- [ ] Formal security audit

### ❌ Not Started

**Future Roadmap:**

**Q2 2026:**
- [ ] Crypto-agility framework
- [ ] Post-quantum crypto (ML-KEM-768 + Dilithium)
- [ ] Encrypted voice calls (WebRTC)

**Q3 2026:**
- [ ] MLS group messaging
- [ ] Multi-device sync
- [ ] Encrypted video calls

**Q4 2026:**
- [ ] Federation protocol
- [ ] End-to-end encrypted backups

---

## References

### Signal Protocol
- [Signal Protocol Specification](https://signal.org/docs/)
- [X3DH Key Agreement](https://signal.org/docs/specifications/x3dh/)
- [Double Ratchet Algorithm](https://signal.org/docs/specifications/doubleratchet/)

### Cryptography
- [RFC 7748: Elliptic Curves for Security](https://datatracker.ietf.org/doc/html/rfc7748)
- [RFC 8439: ChaCha20-Poly1305 AEAD](https://datatracker.ietf.org/doc/html/rfc8439)
- [RFC 8032: Edwards-Curve Digital Signatures](https://datatracker.ietf.org/doc/html/rfc8032)

### Post-Quantum
- [ML-KEM (FIPS 203)](https://csrc.nist.gov/pubs/fips/203/final)
- [ML-DSA Dilithium (FIPS 204)](https://csrc.nist.gov/pubs/fips/204/final)

---

## Additional Documentation

**Full documentation vault:** `~/Documents/Konstruct/`

### Key Documents
- **Architecture:** `03_Server_Backend/00_Server_Architecture/`
- **Complete Flow:** `03_Server_Backend/Documentation/COMPLETE_SYSTEM_FLOW.md`
- **Formal Spec:** `03_Server_Backend/FORMAL_PROTOCOL_SPECIFICATION.md`
- **nextSince Contract:** `03_Server_Backend/Documentation/NEXT_SINCE_CONTRACT.md`
- **State Management:** `03_Server_Backend/STATE_MANAGEMENT_ANALYSIS.md`

### Development

```bash
# Start development environment
make dev-up

# Run tests
make test

# Run specific test suite
cargo test -p construct-server-shared --test rest_api_auth_test

# Deploy to staging
make deploy
```

See `make help` for all available commands.

---

**Last Updated:** 2026-02-15  
**Maintainer:** Construct Team  
**License:** Proprietary

---

## Protocol Buffers / gRPC Migration

**Status:** In progress (hard-cut from legacy REST-first architecture)  
**Detailed Plan:** See `/Users/maximeliseyev/Documents/Konstruct/03_Server_Backend/Refactoring/MASTER_PLAN.md`

### Why Migrating to Protobuf?

1. **Current Issue:** Double serialization (JSON → MessagePack) is wasteful
2. **PQC Readiness:** ML-KEM-768 keys are 1184 bytes, need efficient encoding
3. **WebSocket Native:** Protobuf is designed for binary streaming protocols
4. **Signal Standard:** Official Signal Protocol uses Protobuf format

### Expected Benefits

| Metric | Current (JSON) | After (Protobuf) | Improvement |
|--------|----------------|------------------|-------------|
| Message size | ~200 bytes | ~100 bytes | -50% |
| CPU overhead | Double parsing | Single decode | -30% |
| Battery impact | Baseline | Better | +10% |
| Traffic (100K users) | ~94 GB/day | ~47 GB/day | -50% |

### Timeline

**Phase 1 (Week 1):** Protocol definitions (.proto files)  
**Phase 2 (Week 2):** Server implementation (WebSocket + Protobuf)  
**Phase 3 (Week 3):** Client implementation (Swift Protobuf)  
**Phase 4 (Week 4):** Gradual rollout with A/B testing  

**Backwards Compatibility:** No legacy REST compatibility guarantee; contracts are being narrowed to passwordless + invite/QR discovery model.

### Example Protobuf Schema

```protobuf
// construct.proto
syntax = "proto3";

message EncryptedMessage {
  string recipient_id = 1;
  enum SuiteId {
    CLASSIC_X25519 = 1;
    PQ_HYBRID_KYBER = 2;
  }
  SuiteId suite_id = 2;
  bytes ephemeral_public_key = 3;    // 32 bytes (classic) or 1216 bytes (PQC)
  uint32 message_number = 4;
  uint32 previous_chain_length = 5;
  bytes ciphertext = 6;
}
```

**Size comparison:**
- JSON: `{"recipientId":"uuid","suiteId":2,"ephemeralPublicKey":"base64..."}`
- Protobuf: Binary encoding, ~40% smaller with PQC keys

---
