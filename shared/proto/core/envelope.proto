syntax = "proto3";

package shared.proto.core.v1;

import "core/identity.proto";

// Envelope - Universal message container
// Wraps all message types (text, media, E2EE, MLS, WebRTC signaling)
// Server only sees this outer envelope, content is encrypted
message Envelope {
  // === Core Identity (fields 1-5, common, 1-byte encoding) ===

  // Sender identity
  UserId sender = 1;
  DeviceId sender_device = 2;

  // Recipient identity
  UserId recipient = 3;
  optional DeviceId recipient_device = 4;

  // Content type (determines payload interpretation)
  ContentType content_type = 5;

  // === Message Identification (fields 6-10) ===

  // Message ID (for 1-to-1 direct messages)
  // For group messages, use group_message_id instead
  // This is a oneof to avoid ambiguity
  oneof message_id_type {
    // Direct message ID (UUID v4)
    // Example: "550e8400-e29b-41d4-a716-446655440000"
    string message_id = 6;

    // Group message ID (MLS composite)
    // Example: "abc123:5:2:42" (group_id:epoch:sender:generation)
    GroupMessageId group_message_id = 21; // MOVED TO FIELD 21 (2-byte)
  }

  // Server timestamp (rounded to 5-second buckets for privacy)
  // Prevents server from learning precise message timing
  // For precise timestamps, see encrypted_metadata
  int64 timestamp = 7;

  // TTL (time-to-live) in seconds
  // Server deletes message after TTL expires (0 = no expiration)
  uint32 ttl = 8;

  // Priority (for delivery ordering)
  MessagePriority priority = 9;

  // === Encrypted Payload (field 10) ===

  // Encrypted message content
  // Encryption depends on content_type:
  // - E2EE_SIGNAL: Signal Protocol encrypted
  // - E2EE_MLS: MLS encrypted
  // - WEBRTC_SIGNAL: May be plaintext (SDP/ICE)
  bytes encrypted_payload = 10;

  // === Routing & Metadata (fields 11-15) ===

  // Conversation ID (1-to-1 or group)
  // Format: "direct:{user1}:{user2}" or "group:{group_id}"
  string conversation_id = 11;

  // Server-assigned metadata (added by server, read-only for clients)
  ServerMetadata server_metadata = 12;

  // Client-provided metadata (optional)
  optional ClientMetadata client_metadata = 13;

  // Forwarding chain (for sealed sender)
  // Each hop appends its server ID
  repeated string forwarding_path = 14;

  // Reserved for future common fields
  reserved 15;

  // === Advanced Features (fields 16-50, rare, 2-byte encoding) ===

  // Ephemeral message (disappears after reading)
  optional uint32 ephemeral_seconds = 16;

  // Reply to message ID (for threading)
  optional string reply_to_message_id = 17;

  // Edit of message ID (for message editing)
  optional string edits_message_id = 18;

  // Reactions (emoji reactions to this message)
  repeated Reaction reactions = 19;

  // Mentions (user IDs mentioned in message)
  repeated string mentions = 20;

  // Group message ID moved to field 21 (in oneof above)

  // Reserved for future features (field 22 was reserved for E2eeMetadata but
  // crypto parameters belong inside encrypted_payload, not in the outer envelope)
  reserved 22 to 50;

  // === Reserved for Extensions (fields 51-100) ===

  // Federation routing (future)
  reserved 51 to 60;

  // Sealed sender (fields 61-70)
  // Used only for cross-server (federation) messages where sender must be hidden
  // from destination server. For local messages, use regular sender field above.
  optional SealedSenderEnvelope sealed_sender = 61;
  reserved 62 to 70;

  // Compliance & audit (future)
  reserved 71 to 80;

  // Custom extensions (enterprise)
  reserved 81 to 100;
}

// ContentType - Type of message content
enum ContentType {
  // Unscpecified content type (must be 0)
  CONTENT_TYPE_UNSPECITIED = 0;

  // === E2EE Messages ===

  // Signal Protocol E2EE message (1-to-1)
  CONTENT_TYPE_E2EE_SIGNAL = 1;

  // MLS E2EE message (group)
  CONTENT_TYPE_E2EE_MLS = 2;

  // === Signaling ===

  // WebRTC signaling (SDP, ICE candidates)
  CONTENT_TYPE_WEBRTC_SIGNAL = 10;

  // Presence updates (typing, online, receipts)
  CONTENT_TYPE_PRESENCE = 11;

  // === Control Messages ===

  // Key exchange initiation (X3DH handshake)
  CONTENT_TYPE_KEY_EXCHANGE = 20;

  // Session reset request
  CONTENT_TYPE_SESSION_RESET = 21;

  // Reserved for future types
  reserved 3 to 9, 12 to 19, 22 to 100;
}

// MessagePriority - Delivery priority
enum MessagePriority {
  // Normal priority (default)
  MESSAGE_PRIORITY_NORMAL = 0;

  // High priority (typing indicators, receipts)
  MESSAGE_PRIORITY_HIGH = 1;

  // Critical priority (calls, security alerts)
  MESSAGE_PRIORITY_CRITICAL = 2;

  // Low priority (bulk messages, analytics)
  MESSAGE_PRIORITY_LOW = 3;
}

// ServerMetadata - Server-assigned metadata
// Read-only for clients, set by server during routing
message ServerMetadata {
  // Server-assigned message number (sequential per user inbox)
  // Used for pagination and ordering
  uint64 message_number = 1;

  // Server receive timestamp (audit trail)
  // Precise timestamp when server received message
  int64 server_timestamp = 2;

  // Delivery attempts (for debugging)
  // Incremented on each delivery retry
  uint32 delivery_attempts = 3;

  // Server ID that processed this message (for debugging)
  optional string processing_server_id = 4;

  // Encrypted metadata (for premium privacy users)
  // Contains: precise_timestamp, delivery_hops, processing_time_ms
  // Encrypted with recipient's metadata key (derived from Signal session)
  // See EncryptedMetadataContent for decrypted structure
  optional bytes encrypted_metadata = 5;

  // Reserved for future server metadata
  reserved 6 to 10;
}

// EncryptedMetadataContent - Decrypted content of encrypted_metadata
// This is NOT transmitted in proto, but documented for client implementation
message EncryptedMetadataContent {
  // Actual (non-rounded) timestamp
  // Precise timestamp before 5-second rounding
  int64 precise_timestamp = 1;

  // Delivery path (for debugging)
  // List of server hops: ["server-1", "server-2", "gateway"]
  repeated string delivery_hops = 2;

  // Server processing time in milliseconds
  // Useful for performance monitoring
  uint32 processing_time_ms = 3;

  // Reserved for future encrypted metadata
  reserved 4 to 10;
}

// ClientMetadata - Optional client-provided metadata
message ClientMetadata {
  // Client-generated timestamp (may differ from server_timestamp)
  int64 client_timestamp = 1;

  // Client version (for debugging)
  // Example: "construct-ios/1.2.3"
  optional string client_version = 2;

  // Correlation ID (for request tracing)
  optional string correlation_id = 3;

  // Reserved for future client metadata
  reserved 4 to 10;
}

// GroupMessageId - Composite message ID for MLS groups
// Prevents message ID conflicts in multi-sender groups
message GroupMessageId {
  // Group ID (unique group identifier)
  bytes group_id = 1;

  // MLS epoch (increments on group membership changes)
  uint64 epoch = 2;

  // Sender index in group roster (0-based)
  // Deterministic ordering within epoch
  uint32 sender_index = 3;

  // Generation number (sequential per sender in epoch)
  // Sender's message counter within current epoch
  uint64 generation = 4;

  // Composite ID string (for logging/debugging)
  // Format: "group_id:epoch:sender:generation"
  // Example: "abc123:5:2:42"
  // This is computed, not transmitted
}

// Reaction - Emoji reaction to a message
message Reaction {
  // Reactor's user ID
  string user_id = 1;

  // Emoji unicode (UTF-8)
  // Example: "ðŸ‘", "â¤ï¸", "ðŸ˜‚"
  string emoji = 2;

  // Reaction timestamp
  int64 timestamp = 3;
}

// ============================================================================
// Sealed Sender â€” Split-Knowledge Onion Envelope for Federation Privacy
// ============================================================================
//
// Architecture: no single server sees the full senderâ†’recipient pair.
//
//   Home Server (A):  knows sender (JWT session), sees only recipient_server
//   Dest Server (B):  knows recipient_user_id, cannot see sender
//   Recipient (Bob):  decrypts sender_cert_ciphertext â†’ learns sender identity
//
// Used ONLY for cross-server (federation) messages. Local messages use the
// regular Envelope.sender field since the server already knows both parties.
// ============================================================================

// SealedSenderEnvelope â€” outer wrapper visible to the home server
// Home server uses recipient_server for S2S routing, then forwards sealed_inner
// opaquely to the destination server.
message SealedSenderEnvelope {
  // Destination federation server domain
  // Example: "eu.konstruct.cc"
  string recipient_server = 1;

  // Serialized SealedInner â€” opaque to home server (do NOT parse)
  bytes sealed_inner = 2;

  // Anti-replay HMAC: HMAC-SHA256(server_secret, sealed_inner || timestamp)
  // Home server validates freshness before forwarding
  bytes forwarding_token = 3;

  // Timestamp for freshness check (reject if >5 min old)
  int64 timestamp = 4;

  // Reserved for future routing metadata
  reserved 5 to 15;
}

// SealedInner â€” delivered to the destination server
// Server sees recipient but NOT sender identity.
message SealedInner {
  // Recipient user ID (local to destination server)
  string recipient_user_id = 1;

  // Random anti-replay tag (32 bytes)
  // Destination server stores tags for 24h; duplicate tag = drop
  bytes delivery_tag = 2;

  // SenderCertificate encrypted to recipient's identity key
  // X25519-AEAD-encrypt(ephemeral_key, recipient.identity_key, cert + signature)
  // Server MUST NOT attempt to decrypt this field
  bytes sender_cert_ciphertext = 3;

  // Opaque E2EE payload (Double Ratchet encrypted message)
  bytes encrypted_payload = 4;

  // Content type (needed by server for priority routing / notification text)
  ContentType content_type = 5;

  // Message priority
  MessagePriority priority = 6;

  // TTL in seconds (0 = no expiration)
  uint32 ttl = 7;

  // Reserved for future sealed fields
  reserved 8 to 15;
}

// SenderCertificate â€” encrypted inside sender_cert_ciphertext
// Only the recipient can decrypt and verify this.
// Proves sender identity without revealing it to any server.
//
// Trust chain:
//   1. Sender's home server signs this cert (Ed25519, same key as .well-known/konstruct)
//   2. Sender encrypts cert to recipient's identity key
//   3. Recipient decrypts â†’ verifies server_signature against home server's public key
//   4. Recipient checks sender_identity_key matches existing session
message SenderCertificate {
  // Sender user ID (local to sender's home server)
  string sender_user_id = 1;

  // Sender's home server domain
  // Used to look up server's public key for signature verification
  string sender_domain = 2;

  // Sender's X25519 identity public key (32 bytes)
  // Recipient verifies this matches the existing Signal session
  bytes sender_identity_key = 3;

  // Sender's device ID
  string sender_device_id = 4;

  // Certificate issue time (Unix seconds)
  int64 issued_at = 5;

  // Certificate expiry (Unix seconds, typically issued_at + 24h)
  // Recipient rejects expired certificates
  int64 expires_at = 6;

  // Ed25519 signature by sender's home server
  // Signs: sender_user_id || sender_domain || sender_identity_key || sender_device_id || issued_at || expires_at
  bytes server_signature = 7;

  // Reserved for future cert fields (e.g., PQ signature, capabilities)
  reserved 8 to 15;
}
