# fly.toml app configuration file for Construct Server (WebSocket Gateway)
#
# This is the main application server that handles:
# - WebSocket connections for real-time messaging
# - HTTP REST API for key management, authentication
# - Database interactions (PostgreSQL)
# - Kafka producer (dual-write mode, Phase 2-4)
#
# Deploy with: make deploy-server
# Or: fly deploy --config ops/fly.toml --app construct-server
#
# See https://fly.io/docs/reference/configuration/ for information about how to use this file.

app = 'construct-server'
primary_region = 'ams'

[build]
  # Dockerfile path is specified via --dockerfile flag in Makefile

[env]
  # Rust logging (info level for production, exclude noisy sqlx DEBUG logs)
  # Set to "info,construct_server=debug" for detailed debugging if needed
  RUST_LOG = "info,sqlx=warn,construct_server=info"
  
  # Database connection pool settings
  DB_MAX_CONNECTIONS = "10"
  DB_ACQUIRE_TIMEOUT_SECS = "30"
  DB_IDLE_TIMEOUT_SECS = "600"

  # Server configuration
  PORT = "8080"
  HEALTH_PORT = "8081"

  # Message TTL
  MESSAGE_TTL_DAYS = "7"
  SESSION_TTL_DAYS = "30"
  REFRESH_TOKEN_TTL_DAYS = "90"

  # Rate limiting
  MAX_MESSAGES_PER_HOUR = "1000"
  MAX_CONNECTIONS_PER_USER = "5"

  # Delivery worker config
  # OPTIMIZED: Increased polling interval from 10s to 30s to reduce Redis commands
  # This reduces Redis command usage by ~66% while maintaining acceptable latency
  DELIVERY_POLL_INTERVAL_MS = "30000"
  # OPTIMIZED: Increased heartbeat from 90s to 180s (TTL is 270s, so this is safe)
  # Reduces Redis heartbeat commands by 50%
  HEARTBEAT_INTERVAL_SECS = "180"  # How often server updates its registration
  SERVER_REGISTRY_TTL_SECS = "270"  # TTL for delivery_queue keys (must be > HEARTBEAT_INTERVAL_SECS)

  # Redis prefixes
  ONLINE_CHANNEL = "user_online_notifications:"
  DELIVERY_QUEUE_PREFIX = "delivery_queue:"
  OFFLINE_QUEUE_PREFIX = "offline:"

[http_service]
  internal_port = 8080
  force_https = true
  auto_stop_machines = 'stop'
  auto_start_machines = true
  min_machines_running = 1

  # Health check endpoint
  [[http_service.checks]]
    grace_period = "5s"
    interval = "10s"
    method = "GET"
    path = "/health"
    timeout = "2s"
    protocol = "http"

# VM configuration - WebSocket server needs more resources
[[vm]]
  memory = '1gb'
  cpus = 2

# Deployment strategy - rolling updates to maintain availability
[deploy]
  strategy = "rolling"
  max_unavailable = 1

# Auto-scaling based on WebSocket connections
[autoscaling]
  min_instances = 1
  max_instances = 10

  [[autoscaling.metrics]]
    type = "concurrency"
    target = 500  # Scale when >500 concurrent connections

  [[autoscaling.metrics]]
    type = "cpu"
    target = 75

# Secrets to set via: make secrets-server
# Or: bash ops/setup-fly-secrets.sh
# Required secrets:
# - DATABASE_URL (Supabase PostgreSQL)
# - REDIS_URL (Upstash Redis)
# - JWT_SECRET
# - JWT_ISSUER
# - LOG_HASH_SALT
# - KAFKA_ENABLED=true
# - KAFKA_BROKERS (Confluent Cloud)
# - KAFKA_TOPIC
# - KAFKA_CONSUMER_GROUP
# - KAFKA_SSL_ENABLED=true
# - KAFKA_SASL_MECHANISM=PLAIN
# - KAFKA_SASL_USERNAME
# - KAFKA_SASL_PASSWORD
# - KAFKA_PRODUCER_COMPRESSION=snappy
# - KAFKA_PRODUCER_LINGER_MS=5
# - KAFKA_PRODUCER_ACKS=all
# - DELIVERY_ACK_MODE=kafka
# - DELIVERY_SECRET_KEY
# - INSTANCE_DOMAIN
# - FEDERATION_BASE_DOMAIN
# - APNS_DEVICE_TOKEN_ENCRYPTION_KEY
