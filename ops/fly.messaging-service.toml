# fly.messaging-service.toml - Messaging Service configuration
#
# Messaging service for microservices architecture.
# Handles:
# - Sending messages (POST /api/v1/messages)
# - Getting messages (GET /api/v1/messages?since=<id>)
# - Long polling for new messages
# - Replay protection
# - Message validation
#
# Architecture:
# - Stateless processing
# - Kafka for message queue (source of truth)
# - Redis for replay protection, rate limiting, long polling
#
# Deploy with: make deploy-messaging-service
# Or: fly deploy --config ops/fly.messaging-service.toml --app construct-messaging-service
#
# See https://fly.io/docs/reference/configuration/ for information about how to use this file.

app = 'construct-messaging-service'
primary_region = 'ams'

[build]
  # Dockerfile path is specified via --dockerfile flag in Makefile

[processes]
  app = "messaging-service"

[env]
  # Rust logging level
  RUST_LOG = "info,sqlx=warn,construct_server=info"
  
  # Server configuration
  PORT = "8080"

  # Database connection pool settings (optional, for metadata)
  DB_MAX_CONNECTIONS = "5"
  DB_ACQUIRE_TIMEOUT_SECS = "30"
  DB_IDLE_TIMEOUT_SECS = "600"

  # Rate limiting
  MAX_MESSAGES_PER_HOUR = "1000"
  MAX_LONG_POLL_REQUESTS_PER_WINDOW = "100"
  LONG_POLL_RATE_LIMIT_WINDOW_SECS = "60"

  # Redis prefixes (needed for config parsing)
  ONLINE_CHANNEL = "user_online_notifications:"
  DELIVERY_QUEUE_PREFIX = "delivery_queue:"
  OFFLINE_QUEUE_PREFIX = "offline:"

[http_service]
  internal_port = 8080
  force_https = true
  auto_stop_machines = 'stop'
  auto_start_machines = true
  min_machines_running = 1
  processes = ["app"]

  # Health check endpoint
  [[http_service.checks]]
    grace_period = "5s"
    interval = "10s"
    method = "GET"
    path = "/health"
    timeout = "2s"
    protocol = "http"

# VM configuration - Messaging service needs more resources
[[vm]]
  memory = '1gb'
  cpus = 2

# Deployment strategy - rolling updates
[deploy]
  strategy = "rolling"
  max_unavailable = 1

# Auto-scaling based on request rate
[autoscaling]
  min_instances = 1
  max_instances = 10

  [[autoscaling.metrics]]
    type = "cpu"
    target = 70

  [[autoscaling.metrics]]
    type = "concurrency"
    target = 500

# Secrets to set via: make secrets-messaging-service
# Required secrets:
# - DATABASE_URL (PostgreSQL - for device tokens lookup) - REQUIRED
# - REDIS_URL (for replay protection, rate limiting, long polling) - REQUIRED
# - JWT_SECRET (for JWT verification) - REQUIRED (min 32 chars)
# - JWT_ISSUER (for JWT verification) - Optional (default: "construct-server")
# - LOG_HASH_SALT (for hashing user IDs in logs) - REQUIRED
# - ONLINE_CHANNEL (Redis channel prefix) - REQUIRED
# - DELIVERY_QUEUE_PREFIX (Redis queue prefix) - REQUIRED
# - OFFLINE_QUEUE_PREFIX (Redis queue prefix) - REQUIRED
# - KAFKA_ENABLED=true (if using Kafka)
# - KAFKA_BROKERS (Confluent Cloud, if Kafka enabled)
# - KAFKA_TOPIC (if Kafka enabled)
# - KAFKA_SSL_ENABLED=true (if Kafka enabled)
# - KAFKA_SASL_MECHANISM=PLAIN (if Kafka enabled)
# - KAFKA_SASL_USERNAME (if Kafka enabled)
# - KAFKA_SASL_PASSWORD (if Kafka enabled)
# - KAFKA_PRODUCER_COMPRESSION=snappy (if Kafka enabled)
# - KAFKA_PRODUCER_ACKS=all (if Kafka enabled)
#
# APNs Push Notifications (REQUIRED for push to work):
# - APNS_DEVICE_TOKEN_ENCRYPTION_KEY (64 hex chars) - REQUIRED to decrypt device tokens
# - APNS_ENABLED=true - Enable push notifications
# - APNS_ENVIRONMENT=production|development
# - APNS_KEY_PATH (path to .p8 key file mounted in container)
# - APNS_KEY_ID (10 chars from Apple Developer)
# - APNS_TEAM_ID (from Apple Developer)
# - APNS_BUNDLE_ID (iOS app bundle ID)
# - APNS_TOPIC (usually same as BUNDLE_ID)
