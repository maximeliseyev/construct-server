# =============================================================================
# Construct Server — Production Docker Compose (DigitalOcean VPS)
# =============================================================================
# Architecture:
#   Traefik (TLS/443)
#     └→ Envoy (gRPC-web routing, :8080)
#          └→ Rust microservices (:5005x)
#   Vault (secrets store, :8200)
#   vault-agent (init container: fetches secrets → /secrets/app.env)
#
# External services (not in this compose):
#   Database : Supabase (DATABASE_URL in Vault)
#   Redis    : Upstash  (REDIS_URL in Vault)
#
# First-time setup (run from REPO ROOT, not from ops/):
#   1. cp ops/.env.example .env && nano .env
#   2. docker compose -f ops/docker-compose.prod.yml --env-file .env up -d vault traefik
#   3. docker exec construct-vault vault operator init  # save unseal keys!
#   4. docker exec construct-vault vault operator unseal  # x3
#   5. docker exec construct-vault sh /vault/scripts/vault-setup.sh
#   6. docker compose -f ops/docker-compose.prod.yml --env-file .env up -d
#
# Redeploy after code changes:
#   docker compose -f ops/docker-compose.prod.yml --env-file .env up -d --build --no-deps <service>
#
# NOTE: Always run with --env-file .env from repo root, or create a symlink:
#   ln -s $(pwd)/.env ops/.env
# =============================================================================

name: construct

services:

  # ─── Traefik (TLS + Let's Encrypt) ───────────────────────────────────────

  traefik:
    image: traefik:v3.3
    restart: unless-stopped
    command:
      - "--providers.docker=true"
      - "--providers.docker.exposedByDefault=false"
      - "--providers.docker.network=construct_internal"
      - "--entrypoints.web.address=:80"
      - "--entrypoints.websecure.address=:443"
      - "--entrypoints.web.http.redirections.entrypoint.to=websecure"
      - "--entrypoints.web.http.redirections.entrypoint.scheme=https"
      - "--certificatesresolvers.letsencrypt.acme.email=${ACME_EMAIL}"
      - "--certificatesresolvers.letsencrypt.acme.storage=/letsencrypt/acme.json"
      - "--certificatesresolvers.letsencrypt.acme.tlschallenge=true"
      - "--api.dashboard=true"
      - "--log.level=INFO"
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - traefik-certs:/letsencrypt
    networks:
      - internal
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.traefik.rule=Host(`traefik.${INSTANCE_DOMAIN}`)"
      - "traefik.http.routers.traefik.entrypoints=websecure"
      - "traefik.http.routers.traefik.tls.certresolver=letsencrypt"
      - "traefik.http.routers.traefik.service=api@internal"
      - "traefik.http.routers.traefik.middlewares=auth-basic"
      - "traefik.http.middlewares.auth-basic.basicauth.users=${TRAEFIK_DASHBOARD_AUTH}"

  # ─── Vault (secrets store) ───────────────────────────────────────────────

  vault:
    image: hashicorp/vault:1.19
    container_name: construct-vault
    restart: unless-stopped
    cap_add:
      - IPC_LOCK    # prevents secrets from being swapped to disk
    environment:
      VAULT_ADDR: http://0.0.0.0:8200
    volumes:
      - vault-data:/vault/data
      - vault-auth:/vault/auth       # AppRole credentials (role_id, secret_id)
      - ./vault/vault.hcl:/vault/config/vault.hcl:ro
      - ./vault/vault-setup.sh:/vault/scripts/vault-setup.sh:ro
    command: vault server -config=/vault/config/vault.hcl
    networks:
      - internal
    healthcheck:
      test: ["CMD", "vault", "status", "-address=http://127.0.0.1:8200"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 5s
    labels:
      - "traefik.enable=true"
      # Vault UI only accessible via a separate subdomain, not the main API
      - "traefik.http.routers.vault.rule=Host(`vault.${INSTANCE_DOMAIN}`)"
      - "traefik.http.routers.vault.entrypoints=websecure"
      - "traefik.http.routers.vault.tls.certresolver=letsencrypt"
      - "traefik.http.services.vault.loadbalancer.server.port=8200"

  # ─── Vault Agent (init: fetches secrets → /secrets/app.env) ──────────────

  vault-agent:
    image: hashicorp/vault:1.19
    restart: "no"    # runs once, exits after writing secrets
    volumes:
      - vault-auth:/vault/auth:ro
      - app-secrets:/secrets
      - ./vault/agent.hcl:/vault/config/agent.hcl:ro
    command: vault agent -config=/vault/config/agent.hcl
    environment:
      VAULT_ADDR: http://vault:8200
    networks:
      - internal
    depends_on:
      vault:
        condition: service_healthy

  # ─── Envoy (gRPC-web routing) ─────────────────────────────────────────────

  envoy:
    image: envoyproxy/envoy:v1.37.0
    restart: unless-stopped
    volumes:
      - ./envoy.docker.yaml:/etc/envoy/envoy.yaml:ro
    networks:
      - internal
    depends_on:
      - auth
      - user
      - messaging
      - notification
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.envoy.rule=Host(`${INSTANCE_DOMAIN}`)"
      - "traefik.http.routers.envoy.entrypoints=websecure"
      - "traefik.http.routers.envoy.tls.certresolver=letsencrypt"
      - "traefik.http.services.envoy.loadbalancer.server.port=8080"
      - "traefik.http.services.envoy.loadbalancer.server.scheme=h2c"
      - "traefik.http.routers.envoy.middlewares=cors"
      - "traefik.http.middlewares.cors.headers.accesscontrolallowmethods=GET,POST,OPTIONS"
      - "traefik.http.middlewares.cors.headers.accesscontrolallowheaders=Content-Type,Authorization,X-Grpc-Web,X-User-Agent,X-CSRF-Token,Grpc-Timeout"
      - "traefik.http.middlewares.cors.headers.accesscontrolexposeheaders=Grpc-Status,Grpc-Message,Grpc-Encoding,Grpc-Accept-Encoding"
      - "traefik.http.middlewares.cors.headers.accesscontrolalloworiginlist=${CORS_ALLOWED_ORIGINS:-*}"
      - "traefik.http.middlewares.cors.headers.addvaryheader=true"

  # ─── Core Services ─────────────────────────────────────────────────────────
  # All services:
  #   - Use env_file from Vault-populated /secrets/app.env (via volume mount)
  #   - Only non-secret env vars (PORT, RUST_LOG, INSTANCE_DOMAIN) set here
  #   - Depend on vault-agent to ensure secrets are ready before starting

  auth:
    build:
      context: ..
      dockerfile: ops/Dockerfile
    image: construct-server:${IMAGE_TAG:-latest}
    command: /usr/local/bin/auth-service
    restart: unless-stopped
    env_file:
      - path: /secrets/app.env   # populated by vault-agent at startup
        required: true
    environment:
      PORT: "8081"
      RUST_LOG: ${RUST_LOG:-info,sqlx=warn}
      INSTANCE_DOMAIN: ${INSTANCE_DOMAIN}
      APNS_ENABLED: ${APNS_ENABLED:-false}
      APNS_ENVIRONMENT: ${APNS_ENVIRONMENT:-production}
      MAX_MESSAGES_PER_HOUR: ${MAX_MESSAGES_PER_HOUR:-1000}
      MESSAGE_TTL_DAYS: ${MESSAGE_TTL_DAYS:-7}
      KAFKA_ENABLED: ${KAFKA_ENABLED:-false}
      DELIVERY_ACK_MODE: ${DELIVERY_ACK_MODE:-at_least_once}
      DELIVERY_EXPIRY_DAYS: ${DELIVERY_EXPIRY_DAYS:-7}
      DELIVERY_QUEUE_PREFIX: ${DELIVERY_QUEUE_PREFIX:-delivery}
      OFFLINE_QUEUE_PREFIX: ${OFFLINE_QUEUE_PREFIX:-offline}
      ONLINE_CHANNEL: ${ONLINE_CHANNEL:-online}
    volumes:
      - app-secrets:/secrets:ro
    networks:
      - internal
    depends_on:
      vault-agent:
        condition: service_completed_successfully

  user:
    image: construct-server:${IMAGE_TAG:-latest}
    command: /usr/local/bin/user-service
    restart: unless-stopped
    env_file:
      - path: /secrets/app.env
        required: true
    environment:
      PORT: "8082"
      RUST_LOG: ${RUST_LOG:-info,sqlx=warn}
    volumes:
      - app-secrets:/secrets:ro
    networks:
      - internal
    depends_on:
      vault-agent:
        condition: service_completed_successfully

  messaging:
    image: construct-server:${IMAGE_TAG:-latest}
    command: /usr/local/bin/messaging-service
    restart: unless-stopped
    env_file:
      - path: /secrets/app.env
        required: true
    environment:
      PORT: "8083"
      RUST_LOG: ${RUST_LOG:-info,sqlx=warn}
      MAX_MESSAGES_PER_HOUR: ${MAX_MESSAGES_PER_HOUR:-1000}
      MESSAGE_TTL_DAYS: ${MESSAGE_TTL_DAYS:-7}
    volumes:
      - app-secrets:/secrets:ro
    networks:
      - internal
    depends_on:
      vault-agent:
        condition: service_completed_successfully

  notification:
    image: construct-server:${IMAGE_TAG:-latest}
    command: /usr/local/bin/notification-service
    restart: unless-stopped
    env_file:
      - path: /secrets/app.env
        required: true
    environment:
      PORT: "8084"
      RUST_LOG: ${RUST_LOG:-info,sqlx=warn}
      APNS_ENABLED: ${APNS_ENABLED:-false}
      APNS_ENVIRONMENT: ${APNS_ENVIRONMENT:-production}
    volumes:
      - app-secrets:/secrets:ro
    networks:
      - internal
    depends_on:
      vault-agent:
        condition: service_completed_successfully

  invite:
    image: construct-server:${IMAGE_TAG:-latest}
    command: /usr/local/bin/invite-service
    restart: unless-stopped
    env_file:
      - path: /secrets/app.env
        required: true
    environment:
      RUST_LOG: ${RUST_LOG:-info,sqlx=warn}
    volumes:
      - app-secrets:/secrets:ro
    networks:
      - internal
    depends_on:
      vault-agent:
        condition: service_completed_successfully

  key:
    image: construct-server:${IMAGE_TAG:-latest}
    command: /usr/local/bin/key-service
    restart: unless-stopped
    env_file:
      - path: /secrets/app.env
        required: true
    environment:
      RUST_LOG: ${RUST_LOG:-info,sqlx=warn}
    volumes:
      - app-secrets:/secrets:ro
    networks:
      - internal
    depends_on:
      vault-agent:
        condition: service_completed_successfully

  media:
    image: construct-server:${IMAGE_TAG:-latest}
    command: /usr/local/bin/media-service
    restart: unless-stopped
    env_file:
      - path: /secrets/app.env
        required: true
    environment:
      RUST_LOG: ${RUST_LOG:-info,sqlx=warn}
    volumes:
      - app-secrets:/secrets:ro
    networks:
      - internal
    depends_on:
      vault-agent:
        condition: service_completed_successfully

  mls:
    image: construct-server:${IMAGE_TAG:-latest}
    command: /usr/local/bin/mls-service
    restart: unless-stopped
    env_file:
      - path: /secrets/app.env
        required: true
    environment:
      RUST_LOG: ${RUST_LOG:-info,sqlx=warn}
    volumes:
      - app-secrets:/secrets:ro
    networks:
      - internal
    depends_on:
      vault-agent:
        condition: service_completed_successfully

  sentinel:
    image: construct-server:${IMAGE_TAG:-latest}
    command: /usr/local/bin/sentinel-service
    restart: unless-stopped
    env_file:
      - path: /secrets/app.env
        required: true
    environment:
      RUST_LOG: ${RUST_LOG:-info,sqlx=warn}
    volumes:
      - app-secrets:/secrets:ro
    networks:
      - internal
    depends_on:
      vault-agent:
        condition: service_completed_successfully

  gateway:
    image: construct-server:${IMAGE_TAG:-latest}
    command: /usr/local/bin/gateway
    restart: unless-stopped
    env_file:
      - path: /secrets/app.env
        required: true
    environment:
      PORT: "3000"
      RUST_LOG: ${RUST_LOG:-info}
      INSTANCE_DOMAIN: ${INSTANCE_DOMAIN}
    volumes:
      - app-secrets:/secrets:ro
    networks:
      - internal
    depends_on:
      vault-agent:
        condition: service_completed_successfully

  delivery:
    image: construct-server:${IMAGE_TAG:-latest}
    command: /usr/local/bin/delivery-worker
    restart: unless-stopped
    env_file:
      - path: /secrets/app.env
        required: true
    environment:
      PORT: "8085"
      RUST_LOG: ${RUST_LOG:-info,sqlx=warn}
      DELIVERY_ACK_MODE: ${DELIVERY_ACK_MODE:-at_least_once}
      DELIVERY_EXPIRY_DAYS: ${DELIVERY_EXPIRY_DAYS:-7}
      DELIVERY_QUEUE_PREFIX: ${DELIVERY_QUEUE_PREFIX:-delivery}
      OFFLINE_QUEUE_PREFIX: ${OFFLINE_QUEUE_PREFIX:-offline}
      ONLINE_CHANNEL: ${ONLINE_CHANNEL:-online}
      KAFKA_ENABLED: ${KAFKA_ENABLED:-false}
      KAFKA_SASL_MECHANISM: ${KAFKA_SASL_MECHANISM:-PLAIN}
      KAFKA_SSL_ENABLED: ${KAFKA_SSL_ENABLED:-false}
      KAFKA_CONSUMER_GROUP: ${KAFKA_CONSUMER_GROUP:-construct-delivery}
      KAFKA_TOPIC: ${KAFKA_TOPIC:-messages}
      KAFKA_PRODUCER_ACKS: ${KAFKA_PRODUCER_ACKS:-1}
      KAFKA_PRODUCER_COMPRESSION: ${KAFKA_PRODUCER_COMPRESSION:-none}
    volumes:
      - app-secrets:/secrets:ro
    networks:
      - internal
    depends_on:
      vault-agent:
        condition: service_completed_successfully

volumes:
  traefik-certs:
  vault-data:       # Vault encrypted storage
  vault-auth:       # AppRole credentials (role_id, secret_id)
  app-secrets:      # Populated by vault-agent, read by services

networks:
  internal:
    driver: bridge
