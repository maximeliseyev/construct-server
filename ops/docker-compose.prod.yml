# =============================================================================
# Construct Server — Production Docker Compose (DigitalOcean VPS)
# =============================================================================
# Architecture:
#   Cloudflare Tunnel (cloudflared) — hides origin IP, ECH, bidirectional gRPC
#     ├→ ams.konstruct.cc          → Envoy (:8080, gRPC API)
#     ├→ traefik.ams.konstruct.cc  → Traefik dashboard (:8080)
#     ├→ vault.ams.konstruct.cc    → Vault (:8200)
#     ├→ grafana.ams.konstruct.cc  → Grafana (:3000)
#     └→ prometheus.ams.konstruct.cc → Prometheus (:9090)
#   Envoy — gRPC-web routing to Rust microservices
#   Traefik — kept for internal routing / admin access (no external TLS needed)
#   Vault — secrets store
#   vault-agent — init container: fetches secrets → /secrets/app.env
#
# Cloudflare Tunnel public hostnames are configured in Zero Trust dashboard:
#   https://one.dash.cloudflare.com → Networks → Tunnels → construct → Public Hostnames
#   Each hostname: Type=HTTP, URL=<service>:<port>, enable "HTTP/2 Origin"
#   For ams.konstruct.cc also enable "gRPC"
#
# External services (not in this compose):
#   Database : Supabase (DATABASE_URL in Vault)
#   Redis    : Upstash  (REDIS_URL in Vault)
#
# First-time setup (run from REPO ROOT, not from ops/):
#   1. cp ops/.env.example .env && nano .env
#   2. docker compose -f ops/docker-compose.prod.yml --env-file .env up -d vault traefik
#   3. docker exec construct-vault vault operator init  # save unseal keys!
#   4. docker exec construct-vault vault operator unseal  # x3
#   5. docker exec construct-vault sh /vault/scripts/vault-setup.sh
#   6. docker compose -f ops/docker-compose.prod.yml --env-file .env up -d
#
# Redeploy after code changes:
#   docker compose -f ops/docker-compose.prod.yml --env-file .env up -d --build --no-deps <service>
#
# NOTE: Always run with --env-file .env from repo root, or create a symlink:
#   ln -s $(pwd)/.env ops/.env
# =============================================================================

name: construct

services:
  # ─── Cloudflare Tunnel ───────────────────────────────────────────────────
  # Outbound tunnel to Cloudflare — no inbound ports needed.
  # Create tunnel: Zero Trust → Networks → Tunnels → Create → copy token.
  # Configure public hostnames in the dashboard (see architecture comment above).

  cloudflared:
    image: cloudflare/cloudflared:latest
    restart: unless-stopped
    command: tunnel --no-autoupdate run
    environment:
      - TUNNEL_TOKEN=${CLOUDFLARE_TUNNEL_TOKEN}
    networks:
      - internal

  # ─── Traefik (internal routing + admin dashboards) ───────────────────────
  # With Cloudflare Tunnel, Traefik no longer handles TLS or external traffic.
  # It is kept for internal routing to admin subdomains (vault, grafana, etc.)
  # and for convenience when accessing services directly from the server.

  traefik:
    image: traefik:v3.6
    environment:
      - DOCKER_API_VERSION=1.44
    restart: unless-stopped
    command:
      - "--providers.docker=true"
      - "--providers.docker.exposedByDefault=false"
      - "--providers.docker.network=construct_internal"
      - "--entrypoints.web.address=:80"
      - "--api.dashboard=true"
      - "--log.level=INFO"
    ports:
      - "80:80"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
    networks:
      - internal
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.traefik.rule=Host(`traefik.${INSTANCE_DOMAIN}`)"
      - "traefik.http.routers.traefik.entrypoints=web"
      - "traefik.http.routers.traefik.service=api@internal"
      - "traefik.http.routers.traefik.middlewares=auth-basic"
      - "traefik.http.middlewares.auth-basic.basicauth.users=${TRAEFIK_DASHBOARD_AUTH}"

  # ─── Vault (secrets store) ───────────────────────────────────────────────

  vault:
    image: hashicorp/vault:1.19
    container_name: construct-vault
    restart: unless-stopped
    cap_add:
      - IPC_LOCK # prevents secrets from being swapped to disk
    environment:
      VAULT_ADDR: http://0.0.0.0:8200
    volumes:
      - vault-data:/vault/data
      - vault-auth:/vault/auth # AppRole credentials (role_id, secret_id)
      - ./vault/vault.hcl:/vault/config/vault.hcl:ro
      - ./vault/vault-setup.sh:/vault/scripts/vault-setup.sh:ro
    command: vault server -config=/vault/config/vault.hcl
    networks:
      - internal
    healthcheck:
      # exit 0=unsealed, exit 2=sealed/uninitialized — both mean Vault is running
      test:
        [
          "CMD",
          "sh",
          "-c",
          "vault status -address=http://127.0.0.1:8200; r=$$?; [ $$r -eq 0 ] || [ $$r -eq 2 ]",
        ]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 5s
    labels:
      - "traefik.enable=true"
      # Vault UI only accessible via a separate subdomain, not the main API
      - "traefik.http.routers.vault.rule=Host(`vault.${INSTANCE_DOMAIN}`)"
      - "traefik.http.routers.vault.entrypoints=web"
      - "traefik.http.services.vault.loadbalancer.server.port=8200"

  # ─── Vault Agent (init: fetches secrets → /secrets/app.env) ──────────────

  vault-agent:
    image: hashicorp/vault:1.19
    restart: "no" # runs once, exits after writing secrets
    volumes:
      - vault-auth:/vault/auth:ro
      - /opt/construct/secrets:/secrets
      - ./vault/agent.hcl:/vault/config/agent.hcl:ro
    command: vault agent -config=/vault/config/agent.hcl
    environment:
      VAULT_ADDR: http://vault:8200
    networks:
      - internal
    depends_on:
      vault:
        condition: service_healthy

  # ─── Envoy (gRPC-web routing) ─────────────────────────────────────────────

  envoy:
    image: envoyproxy/envoy:v1.37.0
    restart: unless-stopped
    volumes:
      - ./envoy.docker.yaml:/etc/envoy/envoy.yaml:ro
    networks:
      - internal
    depends_on:
      - auth
      - user
      - messaging
      - notification
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.envoy.rule=Host(`${INSTANCE_DOMAIN}`)"
      - "traefik.http.routers.envoy.entrypoints=web"
      - "traefik.http.services.envoy.loadbalancer.server.port=8080"
      - "traefik.http.services.envoy.loadbalancer.server.scheme=h2c"
      - "traefik.http.routers.envoy.middlewares=cors"
      - "traefik.http.middlewares.cors.headers.accesscontrolallowmethods=GET,POST,OPTIONS"
      - "traefik.http.middlewares.cors.headers.accesscontrolallowheaders=Content-Type,Authorization,X-Grpc-Web,X-User-Agent,X-CSRF-Token,Grpc-Timeout"
      - "traefik.http.middlewares.cors.headers.accesscontrolexposeheaders=Grpc-Status,Grpc-Message,Grpc-Encoding,Grpc-Accept-Encoding"
      - "traefik.http.middlewares.cors.headers.accesscontrolalloworiginlist=${CORS_ALLOWED_ORIGINS:-*}"
      - "traefik.http.middlewares.cors.headers.addvaryheader=true"

  # ─── Core Services ─────────────────────────────────────────────────────────
  # All services:
  #   - Use env_file from Vault-populated /secrets/app.env (via volume mount)
  #   - Only non-secret env vars (PORT, RUST_LOG, INSTANCE_DOMAIN) set here
  #   - Depend on vault-agent to ensure secrets are ready before starting

  auth:
    image: ghcr.io/maximeliseyev/construct-server:${IMAGE_TAG:-0.8.0}
    command: /usr/local/bin/auth-service
    restart: unless-stopped
    env_file:
      - path: /opt/construct/secrets/app.env # populated by vault-agent at startup
        required: true
    environment:
      PORT: "8081"
      RUST_LOG: ${RUST_LOG:-info,sqlx=warn}
      INSTANCE_DOMAIN: ${INSTANCE_DOMAIN}
      APNS_ENABLED: ${APNS_ENABLED:-false}
      APNS_ENVIRONMENT: ${APNS_ENVIRONMENT:-production}
      MAX_MESSAGES_PER_HOUR: ${MAX_MESSAGES_PER_HOUR:-1000}
      MESSAGE_TTL_DAYS: ${MESSAGE_TTL_DAYS:-7}
      KAFKA_ENABLED: ${KAFKA_ENABLED:-false}
      KAFKA_BROKERS: ${KAFKA_BROKERS:-localhost:9092}
      DELIVERY_ACK_MODE: ${DELIVERY_ACK_MODE:-at_least_once}
      DELIVERY_EXPIRY_DAYS: ${DELIVERY_EXPIRY_DAYS:-7}
      DELIVERY_QUEUE_PREFIX: ${DELIVERY_QUEUE_PREFIX:-delivery}
      OFFLINE_QUEUE_PREFIX: ${OFFLINE_QUEUE_PREFIX:-offline}
      ONLINE_CHANNEL: ${ONLINE_CHANNEL:-online}
    volumes:
      - /opt/construct/secrets:/secrets:ro
    networks:
      - internal
    depends_on:
      vault-agent:
        condition: service_completed_successfully

  user:
    image: ghcr.io/maximeliseyev/construct-server:${IMAGE_TAG:-0.8.0}
    command: /usr/local/bin/user-service
    restart: unless-stopped
    env_file:
      - path: /opt/construct/secrets/app.env
        required: true
    environment:
      PORT: "8082"
      RUST_LOG: ${RUST_LOG:-info,sqlx=warn}
    volumes:
      - /opt/construct/secrets:/secrets:ro
    networks:
      - internal
    depends_on:
      vault-agent:
        condition: service_completed_successfully

  messaging:
    image: ghcr.io/maximeliseyev/construct-server:${IMAGE_TAG:-0.8.0}
    command: /usr/local/bin/messaging-service
    restart: unless-stopped
    env_file:
      - path: /opt/construct/secrets/app.env
        required: true
    environment:
      PORT: "8083"
      RUST_LOG: ${RUST_LOG:-info,sqlx=warn}
      MAX_MESSAGES_PER_HOUR: ${MAX_MESSAGES_PER_HOUR:-1000}
      MESSAGE_TTL_DAYS: ${MESSAGE_TTL_DAYS:-7}
      KAFKA_ENABLED: ${KAFKA_ENABLED:-false}
      KAFKA_BROKERS: ${KAFKA_BROKERS:-localhost:9092}
      KAFKA_TOPIC: ${KAFKA_TOPIC:-messages}
      KAFKA_CONSUMER_GROUP: ${KAFKA_CONSUMER_GROUP:-construct-delivery}
      KAFKA_SASL_MECHANISM: ${KAFKA_SASL_MECHANISM:-PLAIN}
      KAFKA_SSL_ENABLED: ${KAFKA_SSL_ENABLED:-false}
    volumes:
      - /opt/construct/secrets:/secrets:ro
    networks:
      - internal
    depends_on:
      vault-agent:
        condition: service_completed_successfully

  notification:
    image: ghcr.io/maximeliseyev/construct-server:${IMAGE_TAG:-0.8.0}
    command: /usr/local/bin/notification-service
    restart: unless-stopped
    env_file:
      - path: /opt/construct/secrets/app.env
        required: true
    environment:
      PORT: "8084"
      RUST_LOG: ${RUST_LOG:-info,sqlx=warn}
      APNS_ENABLED: ${APNS_ENABLED:-false}
      APNS_ENVIRONMENT: ${APNS_ENVIRONMENT:-production}
    volumes:
      - /opt/construct/secrets:/secrets:ro
    networks:
      - internal
    depends_on:
      vault-agent:
        condition: service_completed_successfully

  invite:
    image: ghcr.io/maximeliseyev/construct-server:${IMAGE_TAG:-0.8.0}
    command: /usr/local/bin/invite-service
    restart: unless-stopped
    env_file:
      - path: /opt/construct/secrets/app.env
        required: true
    environment:
      PORT: "8086"
      RUST_LOG: ${RUST_LOG:-info,sqlx=warn}
    volumes:
      - /opt/construct/secrets:/secrets:ro
    networks:
      - internal
    depends_on:
      vault-agent:
        condition: service_completed_successfully

  key:
    image: ghcr.io/maximeliseyev/construct-server:${IMAGE_TAG:-0.8.0}
    command: /usr/local/bin/key-service
    restart: unless-stopped
    env_file:
      - path: /opt/construct/secrets/app.env
        required: true
    environment:
      RUST_LOG: ${RUST_LOG:-info,sqlx=warn}
    volumes:
      - /opt/construct/secrets:/secrets:ro
    networks:
      - internal
    depends_on:
      vault-agent:
        condition: service_completed_successfully

  media:
    image: ghcr.io/maximeliseyev/construct-server:${IMAGE_TAG:-0.8.0}
    command: /usr/local/bin/media-service
    restart: unless-stopped
    env_file:
      - path: /opt/construct/secrets/app.env
        required: true
    environment:
      PORT: "8087"
      RUST_LOG: ${RUST_LOG:-info,sqlx=warn}
    volumes:
      - /opt/construct/secrets:/secrets:ro
    networks:
      - internal
    depends_on:
      vault-agent:
        condition: service_completed_successfully

  mls:
    image: ghcr.io/maximeliseyev/construct-server:${IMAGE_TAG:-0.8.0}
    command: /usr/local/bin/mls-service
    restart: unless-stopped
    env_file:
      - path: /opt/construct/secrets/app.env
        required: true
    environment:
      RUST_LOG: ${RUST_LOG:-info,sqlx=warn}
      METRICS_PORT: "8091"
    volumes:
      - /opt/construct/secrets:/secrets:ro
    networks:
      - internal
    depends_on:
      vault-agent:
        condition: service_completed_successfully

  sentinel:
    image: ghcr.io/maximeliseyev/construct-server:${IMAGE_TAG:-0.8.0}
    command: /usr/local/bin/sentinel-service
    restart: unless-stopped
    env_file:
      - path: /opt/construct/secrets/app.env
        required: true
    environment:
      RUST_LOG: ${RUST_LOG:-info,sqlx=warn}
      METRICS_PORT: "8090"
    volumes:
      - /opt/construct/secrets:/secrets:ro
    networks:
      - internal
    depends_on:
      vault-agent:
        condition: service_completed_successfully

  delivery:
    image: ghcr.io/maximeliseyev/construct-server:${IMAGE_TAG:-0.8.0}
    command: /usr/local/bin/delivery-worker
    restart: unless-stopped
    env_file:
      - path: /opt/construct/secrets/app.env
        required: true
    environment:
      PORT: "8085"
      RUST_LOG: ${RUST_LOG:-info,sqlx=warn}
      DELIVERY_ACK_MODE: ${DELIVERY_ACK_MODE:-at_least_once}
      DELIVERY_EXPIRY_DAYS: ${DELIVERY_EXPIRY_DAYS:-7}
      DELIVERY_QUEUE_PREFIX: ${DELIVERY_QUEUE_PREFIX:-delivery}
      OFFLINE_QUEUE_PREFIX: ${OFFLINE_QUEUE_PREFIX:-offline}
      ONLINE_CHANNEL: ${ONLINE_CHANNEL:-online}
      KAFKA_ENABLED: ${KAFKA_ENABLED:-false}
      KAFKA_BROKERS: ${KAFKA_BROKERS:-localhost:9092}
      KAFKA_SASL_MECHANISM: ${KAFKA_SASL_MECHANISM:-PLAIN}
      KAFKA_SSL_ENABLED: ${KAFKA_SSL_ENABLED:-false}
      KAFKA_CONSUMER_GROUP: ${KAFKA_CONSUMER_GROUP:-construct-delivery}
      KAFKA_TOPIC: ${KAFKA_TOPIC:-messages}
      KAFKA_PRODUCER_ACKS: ${KAFKA_PRODUCER_ACKS:-all}
      KAFKA_PRODUCER_COMPRESSION: ${KAFKA_PRODUCER_COMPRESSION:-none}
    volumes:
      - /opt/construct/secrets:/secrets:ro
    networks:
      - internal
    depends_on:
      vault-agent:
        condition: service_completed_successfully

  # ─── Monitoring ──────────────────────────────────────────────────────────

  prometheus:
    image: prom/prometheus:v3.2.1
    container_name: construct-prometheus
    restart: unless-stopped
    command:
      - "--config.file=/etc/prometheus/prometheus.yml"
      - "--storage.tsdb.path=/prometheus"
      - "--storage.tsdb.retention.time=15d"
      - "--web.enable-lifecycle"
    volumes:
      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml:ro
      - prometheus-data:/prometheus
    networks:
      - internal
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.prometheus.rule=Host(`prometheus.${INSTANCE_DOMAIN}`)"
      - "traefik.http.routers.prometheus.entrypoints=web"
      - "traefik.http.routers.prometheus.middlewares=auth-basic"
      - "traefik.http.services.prometheus.loadbalancer.server.port=9090"

  grafana:
    image: grafana/grafana:11.6.0
    container_name: construct-grafana
    restart: unless-stopped
    environment:
      GF_SERVER_ROOT_URL: "https://grafana.${INSTANCE_DOMAIN}"
      GF_SECURITY_ADMIN_PASSWORD: ${GRAFANA_ADMIN_PASSWORD:-admin}
      GF_USERS_ALLOW_SIGN_UP: "false"
      GF_AUTH_ANONYMOUS_ENABLED: "false"
    volumes:
      - grafana-data:/var/lib/grafana
    networks:
      - internal
    depends_on:
      - prometheus
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.grafana.rule=Host(`grafana.${INSTANCE_DOMAIN}`)"
      - "traefik.http.routers.grafana.entrypoints=web"
      - "traefik.http.services.grafana.loadbalancer.server.port=3000"

volumes:
  traefik-certs:
  vault-data: # Vault encrypted storage
  vault-auth: # AppRole credentials (role_id, secret_id)
  prometheus-data:
  grafana-data:

networks:
  internal:
    driver: bridge
